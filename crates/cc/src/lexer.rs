// https://www.lysator.liu.se/c/ANSI-C-grammar-l.html

pub enum Token {
    K_auto,
    K_break,
    K_case,
    K_char,
    K_const,
    K_continue,
    K_default,
    K_do,
    K_double,
    K_else,
    K_enum,
    K_extern,
    K_float,
    K_for,
    K_goto,
    K_if,
    K_int,
    K_long,
    K_register,
    K_return,
    K_short,
    K_signed,
    K_sizeof,
    K_static,
    K_struct,
    K_switch,
    K_typedef,
    K_union,
    K_unsigned,
    K_void,
    K_volatile,
    K_while,
    Name(&str),
    L_int(E_int),
    L_float(E_float),
    L_str(&str),
    S_ellipsis,
    A_shr,
    A_shl,
    A_add,
    A_sub,
    A_mul,
    A_div,
    A_mod,
    A_and,
    A_xor,
    A_or,
    O_shr,
    O_shl,
    O_inc,
    O_dec,
    O_ptr,
    O_and,
    O_or,
    O_le,
    O_ge,
    O_eq,
    O_ne,
    S_semicolon,
    S_lbrace,
    S_rbrace,
    S_comma,
    S_colon,
    A_assign,
    S_lparen,
    S_rparen,
    S_lsqbr,
    S_rsqbr,
    S_dot,
    O_bitand,
    U_not,
    O_minus,
    U_tilde,
    O_plus,
    Asterisk,
    O_div,
    O_mod,

    O_bitor,
}

pub enum E_int {
    L(i32),
    LL(i64),
    UL(u32),
    ULL(u64),
}

pub enum E_float {
    F(f32),
    L(f64),
}

impl FromStr for Token {
    type Err;
    fn from_str(s: &str) -> Result<Self, Self::Err> {}
}
